-- @path statechart=/CapiTrain/EMF/statechart.ecore
-- @path petrinet=/CapiTrain/EMF/petrinet.ecore

module Petrinet2Statechart;

create OUT: statechart from input: petrinet;

rule Pnet2Statechart {
	from
		pnet: petrinet!Net
	to
		schart: statechart!Statechart (
			topState <- t	
		),
		t: statechart!AND (
			name <- 'top',
			contains <- pnet.places -> collect(p | thisModule.Place2OR(p))
		),
		h: distinct statechart!HyperEdge foreach(transition in pnet.transitions) (
			name <- transition.name,
			rcontains <- thisModule.Place2And(transition.prep)
		)
}

lazy rule Place2And {
	from 
		p: petrinet!Place
	to
		a: statechart!AND (
			name <- 'AND transition'
		)
}

lazy rule Place2OR {
	from
		p: petrinet!Place
	to
		o: statechart!OR (
			name <- '',
			contains <- Set{b}
		),
		b: statechart!Basic (
			name <- p.name
		)
}

lazy rule Transition2HyperEdge {
	from 
		t: petrinet!Transition
	to
		h: statechart!HyperEdge (
			name <- t.name,
			rcontains <- thisModule.Place2And(t.prep)
		)
}


helper context petrinet!Place def : isTheSame (t: petrinet!Transition) : Boolean =
	self.prep.post = t
;

--
--helper context petrinet!Net def : getAllPlaces () : OrderedSet(petrinet!Place) =
--	self.places->iterate( place ; elements : OrderedSet(petrinet!Place) = 
--		OrderedSet{} | elements.append(place)
--		)
--	;

--helper context statechart!OR def : getBasic (n: String) : statechart!Basic =
--	;
