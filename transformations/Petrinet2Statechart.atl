module Petrinet2Statechart;

create OUT: statechart from input: petrinet;

rule Pnet2Statechart {
	from
		pnet: petrinet!Net
	to
		schart: statechart!Statechart (
			topState <- t	
		),
		t: statechart!AND (
			name <- 'top',
			contains <- Set{ors}
		),
		ors : distinct statechart!OR foreach(place in pnet.places)(
			name <- '',
			contains <- thisModule.Place2Basic(place)
		)
}
--
--lazy rule getBasics {
--	from 
--		p: petrinet!Place
--	to
--		b: statechart!Basic (
--			name <- p.name
--		)
--}

lazy rule Place2Basic {
	from
		p: petrinet!Place
	to 
		b: statechart!Basic (
			name <- p.name
		)
}

--
--helper context petrinet!Net def : getAllPlaces () : OrderedSet(petrinet!Place) =
--	self.places->iterate( place ; elements : OrderedSet(petrinet!Place) = 
--		OrderedSet{} | elements.append(place)
--		)
--	;

--helper context statechart!OR def : getBasic (n: String) : statechart!Basic =
--	;

--helper context statechart!Net def : getAllBasics : Set (statechart!Place) =
--	let basicsList : Set (statechart!Place) = 
--		self.getAllPlaces ()->select(currChild | currChild.oclIsTypeOf(statechart!Place))
--	in
--		basicsList->select(basic | basic.name=)
--		->union(leavesList->select(leaf | leaf.size = #medium))
--		->union(leavesList->select(leaf | leaf.size = #small))
--	;

--rule Transition2HyperEdge {
--	from
--    	t: petrinet!Transition
--    to
--	    h:statechart!HyperEdge (
--	    	name <- t.name
--	    )
--}
--
--rule Place2Basic {
--	from
--		p: petrinet!Place
--	to 
--		b: statechart!Basic (
--			name <- p.name
--		),
--		o: statechart!OR (
--			contains <- Set{b}
--		)
--}